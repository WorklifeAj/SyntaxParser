#include "parser.h"
#include "front.h"
#include <stdio.h>
#include <stdlib.h>

int callsemiflag = 0;

/**
 * This is the example Recursive-Descent Parser in pp. 181 - 185 in the
 * textbook
 *
 * Sebesta, R. W. (2012). Concepts of Programming Languages.
 * Pearson, 10th edition.
 *
 *
 * */
void error();
void program() {
  printf("Enter <program>\n");

  // Since P ::= S, we just need to parse a statement
  stmt();

  printf("Exit <program>\n");
}

void stmt() {
  printf("Enter <statement>\n");

  switch (nextToken) {
  case IDENT: // Covers V=E case
    lex();    // Advance to next token
    if (nextToken == ASSIGN_OP) {
      lex();  // Get next token
      expr(); // Parse the expression E
    } else {
      error();
    }
    break;

  case KEY_READ: // Covers read(V)
    lex();       // Process the read operation
    if (nextToken == LEFT_PAREN) {
      lex(); // Consume the left parenthesis
      if (nextToken == IDENT) {
        lex(); // Consume the variable V
        if (nextToken == RIGHT_PAREN) {
          lex(); // Consume the right parenthesis
        } else {
          error(); // Error if no right parenthesis
        }
      } else {
        error(); // Error if no variable inside parentheses
      }
    } else {
      error(); // Error if no left parenthesis after read
    }
    break;

  case KEY_WRITE: // Covers write(V)
    lex();        // Process the write operation
    if (nextToken == LEFT_PAREN) {
      lex(); // Consume the left parenthesis
      if (nextToken == IDENT) {
        lex(); // Consume the variable V
        if (nextToken == RIGHT_PAREN) {
          lex(); // Consume the right parenthesis
        } else {
          error(); // Error if no right parenthesis
        }
      } else {
        error(); // Error if no variable inside parentheses
      }
    } else {
      error(); // Error if no left parenthesis after write
    }
    break;

  case KEY_DO: // Covers do { S } while (C)
    lex();     // Consume 'do'
    if (nextToken == LEFT_CBRACE) {
      lex();  // Consume the left curly brace
      stmt(); // Parse the statement S inside the loop

      if (nextToken == RIGHT_CBRACE) {
        lex(); // Consume the right curly brace

        if (nextToken == KEY_WHILE) {
          lex(); // Consume 'while'
          if (nextToken == LEFT_PAREN) {
            lex();       // Consume the left parenthesis
            condition(); // Parse the comparison C

            if (nextToken == RIGHT_PAREN) {
              lex(); // Consume the right parenthesis
            } else {
              error(); // Error if no right parenthesis after condition
            }
          } else {
            error(); // Error if no left parenthesis after while
          }
        } else {
          error(); // Error if no while after right curly brace
        }
      } else {
        error(); // Error if no right curly brace after statement
      }
    } else {
      error(); // Error if no left curly brace after do
    }
    break;

  default:
    // Handle other cases or error
    error();
    break;
  }
  
  if (nextToken == SEMICOLON) {
    lex();
    if (nextToken == EOF) {
      callsemiflag = 1;
      error();
    }
    stmt();
  }

  printf("Exit <statement>\n");
}

void condition() {
  printf("Enter <condition>\n");

  // Parse the first expression
  expr();

  // Check for each comparison operator
  if (nextToken == LESSER_OP || nextToken == GREATER_OP ||
      nextToken == EQUAL_OP || nextToken == NEQUAL_OP ||
      nextToken == LEQUAL_OP || nextToken == GEQUAL_OP) {

    lex();  // Get the next token
    expr(); // Parse the next expression
  } else {
    // Handle error case
    error();
  }

  printf("Exit <condition>\n");
}

/* expr
 * Parses strings in the language generated by the rule:
 * <expr> -> <term> {(+ | -) <term>}
 */
void expr() {
  printf("Enter <expr>\n");

  /* Parse the first term */
  term();

  /* As long as the next token is + or -, get
  the next token and parse the next term */
  while (nextToken == ADD_OP || nextToken == SUB_OP) {
    lex();
    term();
  }

  printf("Exit <expr>\n");
} /* End of function expr */

/* term
 * Parses strings in the language generated by the rule:
 * <term> -> <factor> {(* | /) <factor>)
 */
void term() {
  printf("Enter <term>\n");
  /* Parse the first factor */
  factor();
  /* As long as the next token is * or /, get the
  next token and parse the next factor */
  while (nextToken == MULT_OP || nextToken == DIV_OP) {
    lex();
    factor();
  }
  printf("Exit <term>\n");
} /* End of function term */

/* factor
 * Parses strings in the language generated by the rule:
 * <factor> -> id | int_constant | ( <expr )
 * */
void factor() {
  printf("Enter <factor>\n");

  // Check if the token is an identifier, integer literal, increment, or
  // decrement
  if (nextToken == IDENT) {
    lex(); // Get the next token

    // Additional check for increment or decrement after a variable
    if (nextToken == INC_OP || nextToken == DEC_OP) {
      lex(); // Get the next token to consume the increment or decrement
             // operator
    }
  } else if (nextToken == INT_LIT) {
    lex(); // Get the next token for numeric literal
  } else {
    // Handle the case for an expression in parentheses
    if (nextToken == LEFT_PAREN) {
      lex();
      expr();

      if (nextToken == RIGHT_PAREN) {
        lex();
      } else {
        error();
      }
    }
    // Not an identifier, integer literal, or left parenthesis
    else {
      error();
    }
  }

  printf("Exit <factor>\n");
}

void error() {
  errortail = 1;
  printf("Error encounter: The next lexeme was %s and the next token was %s \n",
         lexeme, LexNames(nextToken));

  exit(1);
}
